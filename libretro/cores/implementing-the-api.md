# Libretorコアの開発 \~Libretro APIの実装\~

<pre>
Note: 

この記事は<a href="developing-cores.md">Libretorコアの開発</a>からAPIの一覧部分を抜き出したものです。
</pre>

libretro APIは、RetroArchのソースパッケージにある`libretro.h`に記載されている複数の関数から成り立っています。

libretro の実装では、`libretro.h` で記述されている関数をすべてエクスポートした動的ロード可能な実行ファイル (`.dll/.so/.dylib`) または静的ライブラリ (`.a/.lib`) にコンパイルする必要があります。

実装はシングルインスタンスであることを前提としていますので、グローバルなステートの存在も許容されます。また、フロントエンドがこれらの関数を間違った順序で呼び出すと、未定義の動作が発生することに注意してください。

APIヘッダはC99とC++に対応しています。C99では、bool型と`<stdint.h>`を使用しています。

libretro APIを用いたフロントエンドのプログラムフローは、以下のように表現できます。

## 🧨 起動時

### `retro_api_version()`

この関数は、`libretro.h`で定義されている`RETRO_API_VERSION`を返す必要があります。

この関数は、ABI/APIが不一致であるかどうかを判断するためにフロントエンドによって使用されます。

APIに互換性のない変更があった場合は、バージョンが変更されます。`retro_*`構造体への変更や、公開されている関数やその引数への変更は、APIバージョンのバンプ(バージョン更新)を保証します。

### `retro_set_*()`

Libretroはコールバックベースです。

フロントエンドはこの段階ですべてのコールバックを設定し、実装側はこれらの関数ポインタをどこかに保存しなければなりません。

フロントエンドは、後からこれらのコールバックを呼び出すことができます。

### `retro_init()`

この関数は一度だけ呼ばれ、実装側にデータ構造を初期化する機会を与えます。

### 環境コールバック

Libretroにはビデオ、オーディオ、入力用のコールバックがありますが、環境コールバックと呼ばれるコールバックもあります。

このコールバック(`retro_environment_t`)は、libretroの実装側がAPIの機能にアクセスするための一般的な方法で、独自のシンボルを付けるにはあまりにも不明瞭であると考えられています。

これはABIを壊すことなく拡張することができます。このコールバックは、フロントエンドが与えられたリクエストを認識したかどうかを示す`bool`型の戻り値を持っています。

### `retro_set_controller_port_device()`

デフォルトでは、ゲームパッドが実装側(のエミュレートするハードウェア)に接続されていると想定されます。

コアがどのタイプの入力デバイスが差し込まれているかに敏感な場合は、フロントエンドがこの関数を呼び出して、特定のプレイヤーに対して使用するデバイスを設定することがあります。

実装側では、可能であればこれを自動検出するようにしてください。

### `retro_get_system_info()`

フロントエンドは通常、実装の名前やバージョン番号など、コアに関する静的に知られている情報を要求します。返された情報は、静的に割り当てられていなければなりません。

### `retro_load_game()`

この関数はコンテンツをロードします。

実装がエミュレータであれば、ゲームのROMイメージ、ゲームエンジンであれば、ゲーム用のパッケージ化されたアセットなどが考えられます。

この関数は、ROMがロードされたパスを示す構造体と、すでにロードされたファイルのメモリチャンクを受け取ります。

**libretroでのファイルの読み込みには2つのモードがあります。** ゲームエンジンが ROMイメージがどこからロードされたかのパスを知る必要がある場合、`retro_system_info`の`need_fullpath`フィールドを`true`に設定する必要があります。パスが必要な場合、フロントエンドは `data/size`フィールドにファイルをロードせず、ディスクからファイルをロードするかどうかは実装次第となります。パスには相対パスと絶対パスがありますが、実装では両方のケースをチェックする必要があります。この機能は、ROMイメージが大きすぎて一度にメモリにロードできない場合に有効です。また、コンテンツが多くの小さなファイルで構成されている場合、他のファイルのパスを推論するためにマスターファイルのパスを知る必要がある場合にも便利です。

`need_fullpath`を`false`に設定すると、フロントエンドはあらかじめROMイメージをメモリにロードしておきます。このモードでは、`path`フィールドが非NULLであることは保証されません。ファイルが実際にディスクから読み込まれた場合には有効なパスを指すはずですが、 標準入力などから読み込まれた場合には明確なパスが存在しない可能性があります。可能であれば、`need_fullpath`を`false`に設定することをお勧めします。これにより、ソフトパッチなどの機能が正しく動作するようになります。

### `retro_get_system_av_info()`

この関数は、フロントエンドにゲームの重要なオーディオ/ビデオのプロパティを知らせるものです。

この情報は読み込まれたゲームに依存することがあるため、有効なROMイメージが読み込まれた後にのみ問い合わせが行われます。

FFmpegによる録画は、数時間同期して実行できるように正確な情報に依存しているため、FPSとオーディオサンプリングレートを正確に報告することが重要です。

## 💥 実行時

### `retro_run()`

ゲームが正常にロードされた後、`retro_run()`はユーザーが望む限り、繰り返し呼び出されます。

呼び出されると、実装側は1ビデオフレーム分、そのコアを実行させます。

この間、実装側はビデオフレームやオーディオサンプルのコールバックを自由に呼び出すことができ、また入力をポーリングしたり、現在の入力状態を問い合わせたりすることができます。

コールバックの要件は、ビデオコールバックが一度だけ呼ばれることです。最後に呼ばれる必要はありません。

また、入力ポーリングは少なくとも一度は呼び出される必要があります。

### 入力

ゲームパッドなどの入力デバイスの抽象化は、システムごとに異なるため、マルチシステムのAPIを定義する上で最も難しい部分です。

そこでlibretro APIでは、ゲームパッドやジョイスティックを抽象化した`RetroPad`を提供し、プラットフォーム固有の入力コードを使わずにコアを記述できるようにしています。

また、キーボード、マウス、ポインター、ライトガンなどの入力デバイスの抽象化も可能です。

**詳細は、[Input APIのドキュメント](https://github.com/libretro/docs/blob/master/docs/development/input-api.md)をご覧ください。**

### Video/Audio synchronization considerations

Libretroは固定レートを基本としており、ビデオのFPSやオーディオのサンプリングレートは常に一定であることを前提としています。

フロントエンドは再生速度をコントロールします。通常はVSyncを使って正しい速度を得ます。

フロントエンドは、「早送り」、つまり、待ち時間なしにできるだけ早く再生することや、スローモーションにすることができます。

このような理由から、エンジンはシステムタイマーに依存して任意の同期を行うべきではありません。

これは一般的なことで、3Dゲームでは、再生可能なゲームを維持しながらフレームレートの変化を考慮するためにしばしば必要となります。

しかし、libretro は100%のリアルタイム性能が常に得られる、つまり処理落ちなどがない、と想定できる古いゲームコンソールなどのシステムを対象としているため、慎重なタイミングコードの必要性はありません。

デフォルトでは、libretroの実装は、任意の`sleep()`や`time()`パターンを、単にビデオ/オーディオのコールバックの呼び出しに置き換えるべきです。

フロントエンドでは、適切な同期が行われるようになっています。これは主に、PrBoomのようなゲームの移植版で問題となります。タイマーとスリープパターンに大きく依存していたPrBoomのlibretro移植版では、スリープを単に1フレーム実行してビデオコールバックを呼び出すことに置き換えました。その後、1フレーム分の時間（1/fps秒）に対応するだけの音声がレンダリングされました。スリープやタイミングのパターンはすべて取り除かれ、同期も正しく行われるようになりました。

### オーディオコールバックについて

libretro APIには、2種類のオーディオコールバックがあります。どちらか一方のみを使用し、実装側でどちらのコールバックが最適かを選択する必要があります。

1つのオーディオフレームは、常に2つの`int16_t`のサンプルで構成されており、それぞれが左チャンネルと右チャンネルに対応しています。

#### Per-sample audio

最初のオーディオコールバックは`per-sample`と呼ばれていますが、実際には1つのオーディオフレームを扱います。

このコールバックは次のシグネチャを持っています。`void (*retro_audio_sample_t)(int16_t left, int16_t right)`

これは、実装側が一度に1つのオーディオフレームを生成する場合に使用されるべきです。フロントエンドは、オーディオデータを適切なチャンクに分割して、システムコールのオーバーヘッドが大きくならないようにします。

#### Batch audio

オーディオが「バッチ」方式で出力されている場合、つまり一度に1/fps秒分のオーディオデータが出力されている場合は、バッチアプローチを考慮する必要があります。

すべてのオーディオフレームをループして、サンプルごとのコールバックを毎回呼び出すのではなく、バッチコールバックを使用してください。

このコールバックは次のシグネチャを持っています。`size_t (*retro_audio_sample_batch_t)(const int16_t * samples, size_t num_frames)`

このコールバックによって供給されるサンプル数は `2 * num_frames` であるべきで2の倍数なのは左右のチャンネルに対応しています。

バッチコールバックを使用すると、オーディオは一時的なバッファにコピーされないため、わずかながらパフォーマンスが向上します。また、すべてのデータが一度にオーディオドライバにプッシュされるので、若干のオーバーヘッドを節約できます。

非常に少量のデータ（32フレーム以下）にバッチコールバックを使用することはお勧めできません。バッチコールバックに渡されるデータは、オーディオのSIMD処理を高速化するために、可能であれば16バイト（プラットフォームによって異なります）にアラインメントする必要があります。

### `retro_serialize_size()`, `retro_serialize()`, `retro_unserialize()`

シリアライズの実装はオプションです。シリアライズは、エミュレータでは「状態の保存」としてよく知られていますが、これらの関数は、固定量の状態を持つエミュレータでは確かに便利です。

この機能により、フロントエンドはすべての内部状態のスナップショットを取り、後でそれを復元することができます。この機能は、巻き戻しやネット対戦の実装に使用されます。

これらの機能をうまく実装するためには、いくつかの重要な注意事項があります。

- シリアライズがサポートされていない場合、`retro_serialize_size()`は`0`を返すべきです。`retro_serialize_size()`が`0`以外の値を返す場合、フロントエンドはシリアライズが適切に実装されていると考えます。
- フロントエンドは、正しくシリアライズするために必要なメモリ量を決定するために、`retro_serialize()`を呼び出す前に、`retro_serialize_size()`を呼び出す必要があります。
- 最終的に `retro_serialize()` に渡されるサイズは、少なくとも `retro_serialize_size()` で返される値のサイズでなければなりません。大きすぎるバッファが `retro_serialize()` に渡された場合、余分なデータは無視されるか`0`に設定されるはずです。
- `retro_serialize_size()`が返す値は、時間とともに減少する可能性はありますが、増加することはありません。これは、`retro_load_game()`の直後に、次のシリアライズを保持するのに十分な大きさの固定されたセーブステートのサイズを事前に決定する能力によって合理化されます。この確実性は巻き戻し実装の基本です。この要件は、`retro_load_game()`と`retro_unload_game()`の呼び出しの間でのみ有効です。

可能であれば、メモリバッファ内の一貫したオフセットでデータをシリアライズするように実装する必要があります。

これにより、RetroArchの巻き戻し実装がより少ないメモリで済むようになります。

`retro_serialize()` と `retro_unserialize()` はどちらも、実装がシリアライズやアンシリアライズに成功したかどうかをフロントエンドに知らせるために、ブール値を返します。

## 💧 終了時

### `retro_unload_game()`

ユーザーがプレイを終了する際は、`retro_unload_game()`が呼び出されます。

これにより、ゲームに関連する内部データが解放され、`retro_load_game()`が再び呼べるようになります。

### `retro_deinit()`

この関数は、`retro_init()`中に初期化されたすべての状態を解放します。この関数を呼び出した後、フロントエンドは再び `retro_init()` を呼び出すことができます。

## 🧶 マルチスレッド時の安全性について

libretro API はスレッドの安全性については保証しません。

したがって、コアの開発者は libretroヘッダで宣言された関数がリエントラントではなく、また複数のスレッドから同時に呼び出されても安全ではないと考えるべきです。

コアがマルチスレッドの場合、コアの開発者は libretro APIを呼び出す際のスレッドの安全性について責任を負います。

`retro_run()`の外で、つまりメインスレッドの外で libretro APIコールを行うことは推奨されません。

